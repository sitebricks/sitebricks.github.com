{"id":"config","title":"Configuration","html":"<p></p>  \n<p>Sitebricks support two configuration patterns :</p> \n<ul> \n <li>Annotation : using @Show, @Service and @EmbedAs</li> \n <li>Modular : using Guice like configuration</li> \n</ul> \n<p>Differences between the two patterns are described below.</p> \n<h3>Annotation configuration</h3> \n<p>Declaration of a basic page</p> \n<pre><code>@At(&quot;/movies&quot;)\n@Show(MoviesPage.class)\npublic class MoviesPage {\n    ...\n}\n</code></pre> \n<p>Declaration of a service</p> \n<pre><code>@At(&quot;/actors&quot;)\n@Service(ActorsPage.class)\npublic class ActorsPage {\n    ...\n}\n</code></pre> \n<p>Declaration of brick</p> \n<pre><code>@EmbedAs(&quot;Soundtrack&quot;)\npublic class SoundtrackPage {\n    ...\n}\n</code></pre> \n<p>Finally scan the root package that contains all your classes</p> \n<pre><code>public class MyAppConfig extends SitebricksModule {\n    @Override\n    protected void configureSitebricks() {\n        scan(Example.class.getPackage());\n    }\n}\n</code></pre> \n<h3>Modular configuration</h3> \n<p>As an alternative to package scanning and the use annotations, Sitebricks provides a modular, declarative configuration style. You may find this preferable for several reasons:</p> \n<ul> \n <li>Capture all page mappings in one place</li> \n <li>Avoid package scanning because it loads classes that are not all pages</li> \n <li>Avoid package scanning because it is slow</li> \n <li>Avoid package scanning because it is unfeasible (for example, in Google Appengine)</li> \n <li>Package a Sitebricks library for distribution as a drop-in module</li> \n</ul> \n<p>Declaration of a basic page, a service and a brick.</p> \n<pre><code>public class MyAppConfig extends SitebricksModule {\n    @Override\n    protected void configureSitebricks() {\n        at(&quot;/movies&quot;).show(MoviesPage.class); // basic page\n        at(&quot;/actors&quot;).serve(ActorsPage.class); // service\n        embed(SoundtrackPage.class).as(&quot;Soundtrack&quot;); // brick\n    }\n}\n</code></pre> \n<h4>Scopes</h4> \n<p>Since this is just a normal Guice module, any of the at() or embed() rules for page objects can be scoped like a normal Guice binding:</p> \n<pre><code>public class MyAppConfig extends SitebricksModule {\n    @Override\n    protected void configureSitebricks() {\n        at(&quot;/movies&quot;).show(MoviesPage.class).in(Scopes.SINGLETON);\n    }\n}\n</code></pre> \n<p>This ensures that the same instance of class MoviesPage services all requests in the entire application. </p> \n<h4>Static resources</h4> \n<p><em>Note:</em> this method is currently only supported for text resources.</p> \n<p>If you are packaging a library for other users to consume as a Sitebricks module, it is sometimes useful to be able to include static resources like css or javascript.</p> \n<p>Sitebricks allows you to declare static resources served at URI paths in the same manner as page objects. To do this you must use a slightly modified at() directive. Let's say the file you wanted to serve was bricks.css, sitting in the same package as your Sitebricks module. You can expose it at URL /static/sitebricks.css as follows:</p> \n<pre><code>public class MyAppConfig extends SitebricksModule {\n    @Override\n    protected void configureSitebricks() {\n        at(&quot;/static/sitebricks.css&quot;).export(&quot;bricks.css&quot;);\n    }\n}\n</code></pre> \n<p>Although it is not a great idea to serve large static resources in this method, it can be good for making a simple, useful library.</p>","postedOn":"01 Oct 2012"}