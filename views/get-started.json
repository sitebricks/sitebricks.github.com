{"id":"get-started","title":"Getting Started","html":"<p></p>  \n<p>Sitebricks is available through Maven and releases are published to Central fairly often.</p> \n<h3>Using Maven</h3> \n<p>You can add a dependency on Sitebricks in your Maven project.</p> \n<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.google.sitebricks&lt;/groupId&gt;\n  &lt;artifactId&gt;sitebricks&lt;/artifactId&gt;\n  &lt;version&gt;0.8.5&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> \n<p>At the time of writing, <em>0.8.5</em> is the most recent release version. <em>0.8.6-SNAPSHOT</em> is the current development version. If you want the features in it, you should build from source instead.</p> \n<h3>Building from source</h3> \n<p>To build from source you will need at least Maven 2.2.1 (3.0.3 also works) and git installed.</p> \n<p>First check out the sources from Github:</p> \n<pre><code>git clone https://github.com/dhanji/sitebricks.git sitebricks\n</code></pre> \n<p>Now build Sitebricks and install it in your local Maven repository.</p> \n<pre><code>cd sitebricks\nmvn install\n</code></pre> \n<p>If everything is successful, you should have a copy of Sitebricks snapshot jars in your local repository. Remember to use the snapshot version in your pom.xml:</p> \n<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.google.sitebricks&lt;/groupId&gt;\n  &lt;artifactId&gt;sitebricks&lt;/artifactId&gt;\n  &lt;version&gt;0.8.6-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> \n<p>If you have no idea how to create a Maven <code>pom.xml</code>, check out the <a href=\"#maven\">Maven Guide</a>.</p> \n<h3>What next?</h3> \n<p>You will place your compiled classes inside the WEB-INF/ directory in another dir called classes. You may place html templates side by side with the classes OR in the root (where <code>Example.html</code> resides) of the webapp as you like.</p> \n<p>We'll take the following steps to write a web application in Sitebricks:</p> \n<ul> \n <li>Create a Guice injector, configuring Sitebricks and Guice Servlet</li> \n <li>Create a page object in <code>Example.java</code> to back an HTML template called <code>Example.html</code></li> \n <li>Customize the page to give it some dynamic behavior</li> \n</ul> \n<h3>Configuring Sitebricks</h3> \n<p>First let's create and configure our Guice injector. This is done via a <code>ServletContextListener</code> that runs once right after the webapp is deployed. Let's call this <code>MyGuiceCreator</code> and place it in the <code>org.example.web</code> package:</p> \n<pre><code>package org.sitebricks.example;\n\npublic class AppConfig extends GuiceServletContextListener {\n\n    @Override\n    public Injector getInjector() {\n        return Guice.createInjector(new SitebricksModule());\n    }\n}\n</code></pre> \n<p>This tells Guice to route all incoming requests to Sitebricks (if Sitebricks cannot handle them, they will be handed back to the normal servlet pipeline as per web.xml). This also lets us take advantage of Guice's powerful web-scopes functionality.</p> \n<p>OK, so far so good. Now we need to tell Sitebricks what packages to scan for pages. This is done by adding another step to <code>AppConfig</code>:</p> \n<pre><code>@Override\npublic Injector getInjector() {\n    return Guice.createInjector(new SitebricksModule() {\n        @Override\n        protected void configureSitebricks() {\n            // scan class Example's package and all descendants\n            scan(Example.class.getPackage());\n        }\n    });\n}\n</code></pre> \n<p>Now register this and <code>GuiceFilter</code> in your web.xml. It should look as follows:</p> \n<pre><code>&lt;filter&gt;\n    &lt;filter-name&gt;webFilter&lt;/filter-name&gt;\n    &lt;filter-class&gt;com.google.inject.servlet.GuiceFilter&lt;/filter-class&gt;\n&lt;/filter&gt;\n\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;webFilter&lt;/filter-name&gt;\n    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/filter-mapping&gt;\n\n&lt;listener&gt;\n    &lt;listener-class&gt;org.sitebricks.example.AppConfig&lt;/listener-class&gt;\n&lt;/listener&gt;\n</code></pre> \n<h3>My First Web Page</h3> \n<p>Now let's create class <code>Example</code> that we just talked about:</p> \n<pre><code>@At(&quot;/&quot;)\npublic class Example {\n  private String message = &quot;Hello&quot;;\n\n  public String getMessage() { return message; }\n}\n</code></pre> \n<p>The <code>@At</code> annotation tells Sitebricks to expose this web page at url <code>&quot;/&quot;</code>. So if you deploy to localhost at port 8080 and visit URL <code>http://localhost:8080/</code> in a browser, page <code>Example</code> will appear.</p> \n<p><em>Note: This annotation is detected by scanning packages. If you don't like this, you can use the alternate [ModularConfig modular configuration approach]</em></p> \n<p>The HTML template for Example was already sitting the zip archive root. This looked as follows:</p> \n<pre><code>&lt;html&gt;\n&lt;body&gt;\n  @ShowIf(true)\n  &lt;p&gt;${message} from Sitebricks!&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> \n<p>This is a fairly simple template that renders some text inside a <code>&lt;p&gt;</code> (paragraph) tag. The expression <code>${message}</code> is evaluated at runtime against an instance of Example. In our case, this evaluates to the string: <code>&quot;Hello&quot;</code>.</p> \n<p>The other interesting part about this template is a <em>brick annotation</em>, named <code>@ShowIf</code>. This tells Sitebricks to convert the <code>&lt;p&gt;</code> tag into a brick with some dynamic behavior (in this case, shown if an expression evaluates to <em>true</em>). The expression passed to <code>@ShowIf(true)</code> is always true (!), so the <code>&lt;p&gt;</code> tag and its contents are always rendered.</p> \n<h3>Adding Some Behavior</h3> \n<p>Let's make this example a bit more interesting. First, let's make <code>@ShowIf</code> take a boolean variable read from the page object:</p> \n<pre><code>@ShowIf(appear)\n&lt;p&gt;${message} from Sitebricks!&lt;/p&gt;\n\n...\n</code></pre> \n<p>And add it as a field to class <code>Example</code>:</p> \n<pre><code>@At(&quot;/&quot;)\npublic class Example {\n  private boolean appear = true;\n  private String message = &quot;Hello&quot;;\n\n  public boolean getAppear() { return appear; }\n  public String getMessage() { return message; }\n}\n</code></pre> \n<p><em>Note: getters for each field are needed if reading them from the template</em> (Alternatively, you could make them public).</p> \n<p>Now, the page still looks the same but the behavior is more dynamic.</p> \n<h3>Even more behavior ;)</h3> \n<p>Now let's make this user-controllable by placing a link on the page:</p> \n<pre><code>&lt;a href=&quot;?appear=${!appear}&quot;&gt;show/hide&lt;/a&gt;\n\n@ShowIf(appear)\n&lt;p&gt;${message} from Sitebricks!&lt;/p&gt;\n\n...\n</code></pre> \n<p>The link <em>show/hide</em> causes a browser to request the same page but with a parameter <code>appear</code>. By placing the expression <code>${!appear}</code> next to it, we toggle the boolean value of appear in the link. Now each time the page is requested, Sitebricks will bind the value in the query string to the field <code>appear</code> in <code>Example</code>. This requires that either <code>appear</code> is public or that a setter is exposed.</p> \n<pre><code>@At(&quot;/&quot;)\npublic class Example {\n  // ... details elided\n  public void setAppear(boolean appear) { this.appear = appear; }\n}\n</code></pre> \n<p>Now run your app and try clicking the link.</p> \n<p>That's it! Try the <a href=\"#5mintutorial\">5 Minute Tutorial</a> to see how to create your own custom bricks and handle HTTP events.</p>","postedOn":"12 Dec 2011"}