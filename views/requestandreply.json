{"id":"requestandreply","title":"Request and Reply","html":"<p></p>  \n<p>Sitebricks provides Request and Reply </p> \n<h3>Request</h3> \n<p>The Request object is an abstract of a request (HTTP request, a tunneled Sitebricks RPC-over-, ...). It can be automaticly injected in a @Service or a @Show class.</p> \n<pre><code>@At(&quot;/person&quot;)\n@Service\npublic class PersonPage {\n\n    @Get\n    public Reply&lt;?&gt; get(Request request) {\n        ...\n    }\n\n}\n</code></pre> \n<p>The Request can directly unmarshal an object with a specified transport.</p> \n<pre><code>Person p = request.read(Person.class).as(Json.class);\n</code></pre> \n<p>Or read the request stream.</p> \n<pre><code>OutputStream out = tmpFileOutputStream();\nreq.readTo(out);\n</code></pre> \n<h4>Handling Post and Get parameters</h4> \n<p>To get the values of Post and Get Parameters, the target class should declare setters for each excepted parameter.</p> \n<pre><code>@At(&quot;/person&quot;)\n@Service\npublic class PersonPage {\n\n    private Integer id;\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    @Get\n    public Reply&lt;?&gt; get(Request request) {\n        // this.id is set !\n        ...\n    }\n\n}\n</code></pre> \n<h3>Reply</h3> \n<p>The <code>Reply&lt;E&gt;</code> object is typed with the class of the <em>entity</em> you want to respond with. In HTTP terms, an entity is an instance of a resource that you want to serve. For example, a shopping cart or a product item. The reply then serves as a wrapper API that generates the relevant HTTP response with the provided entity.</p> \n<p>If I wanted to send an entity as json rather than a plain text string, I can do so by configuring the reply appropriately:</p> \n<pre><code>@Get\nReply&lt;Product&gt; view() {\n  return Reply.with(new Product(&quot;Anti-ageing cure&quot;))\n              .as(Json.class);\n}\n</code></pre> \n<p>In this case, the <code>as()</code> rule is given a class that implements the <code>Transport</code> interface. You can create your own transports that generate content in whatever format you like (be it JPEG or ZIP or SOAP) or you can use one of the provided transports for convenience:</p> \n<ul> \n <li><code>Xml.class</code> - XStream based XML transport</li> \n <li><code>Json.class</code> - Jackson based Json transport</li> \n <li><code>Text.class</code> - Calls toString() on the entity and writes a UTF-8 String</li> \n</ul> \n<h4>Response Headers</h4> \n<p>Replies also allow you to set commonly used headers (such as content type) with a simple API step:</p> \n<pre><code>@Get\nReply&lt;Product&gt; view() {\n  return Reply.with(product)\n              .as(Json.class)\n              .type(&quot;application/json+product_viewer&quot;);\n}\n</code></pre> \n<p>This overrides the default content type set by the <code>Json.class</code> transport (text/json).</p> \n<p>Of course, you can also specify exactly what headers you want directly, with a map:</p> \n<pre><code>@Get\nReply&lt;Product&gt; view() {\n  Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;();\n  headers.put(&quot;Content-Type&quot;, &quot;application/json&quot;);\n  headers.put(&quot;X-Shopcart-Product-ID&quot;, &quot;123456&quot;);\n\n  return Reply.with(product)\n              .as(Json.class)\n              .headers(headers);\n}\n</code></pre> \n<h4>Statuses</h4> \n<p>Replies allow you to set the status of a response too. If you don't set one, the status code for <code>OK</code> (200) is set by default. Otherwise you can use one of the convenience methods to both set a status and perform an action.</p> \n<p>This sends a permanent redirect (301):</p> \n<pre><code>@Get\nReply&lt;?&gt; moved() {\n  return Reply.saying()\n              .seeOther(&quot;http://moved.permanently.com/other&quot;);\n}\n</code></pre> \n<p>This shows resource not found error (404):</p> \n<pre><code>@Get\nReply&lt;?&gt; err() {\n  return Reply.saying()\n              .notFound();\n}\n</code></pre> \n<p>... and so on. You can also explicitly set a status code of your own choice:</p> \n<pre><code>@Get\nReply&lt;?&gt; something() {\n  return Reply.with(&quot;some message&quot;)\n              .status(900);\n}\n</code></pre> \n<h4>Templates</h4> \n<p>If you wish, you can render templates from these web services too. Here is the syntax:</p> \n<pre><code>@At(&quot;/person&quot;) @Service\npublic class PersonService {\n\n  @Get\n  Reply&lt;Person&gt; hello() {\n    return Reply.with(new Person(..))\n                .template(Person.class);\n  }\n}\n</code></pre> \n<p>Here, the class <code>Person</code> is used as the template indicator. Sitebricks expects that your data model object to be backed by a template:</p> \n<pre><code>@Show(&quot;PersonTemplate.html&quot;)\nclass Person {\n  ...\n}\n</code></pre> \n<p>This way, we cleanly separate model/view and control logic in our web services, in a concise and type-safe manner.</p> \n<p>See also <a href=\"#template\">Template API</a></p>","postedOn":"07 Oct 2012"}