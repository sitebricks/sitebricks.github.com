{"id":"page-chaining","title":"Page Chaining","html":"<p></p>  \n<h3>The Problem</h3> \n<p>This is a common problem, where some state reached in one page, needs to be sent to the next page that the user is being redirected to. For example, in page 1 you gather some form data, and need to send that form data to page 2.</p> \n<p>The traditional solution to this is to encode the data in the URL sent as a redirect to page 2. For example:</p> \n<p>Page 1 returns a redirect to <code>/page2/?message=validation+failed</code>, and page2 can display this message as appropriate. However, this is not always suitable for several reasons:</p> \n<ul> \n <li>It leaks information to the user</li> \n <li>It adds a lot of gunk to the query string</li> \n <li>Not all state may be easily encoded as a short string</li> \n</ul> \n<p>So what we need is a way to do this, per-user, on the server-side. And something that is not as heavyweight as going to a persistent datastore.</p> \n<h3>The Solution</h3> \n<p>Page chaining is Sitebricks's idiomatic support for the post-and-redirect design pattern. Of course, you don't have to use it with the POST method, alone. Let's say PizzaPage and OrderPage are two pages in a workflow:</p> \n<ol> \n <li><code>PizzaPage</code> - Choose a topping</li> \n <li><code>OrderPage</code> - Place an order for pizza</li> \n</ol> \n<p>In the first page, the user chooses their toppings:</p> \n<pre><code>@At(&quot;/pizza&quot;)\npublic class PizzaPage {\n  private Topping topping;\n\n  @Post\n  public OrderPage post() {\n    return new OrderPage(topping);\n  }\n\n  ...\n}\n</code></pre> \n<p>Notice that I am returning a value from the <code>@Post</code> handler. The returned value is the target page that we want the user to be redirected to. This is type-safe and clear. Furthermore, I can return the instance of the page itself that I want Sitebricks to use to serve the request.</p> \n<p>The <code>OrderPage</code>, when displayed to the user on redirect, will contain the topping value given to it in the <code>PizzaPage#post()</code> method:</p> \n<pre><code>@At(&quot;/order&quot;)\npublic class OrderPage {\n  private final Topping topping;\n\n  public OrderPage(Topping topping) {\n    this.topping = topping;\n  }\n\n  @Get void order() { .. }\n}\n</code></pre> \n<p>The next time this same workflow is encountered (or if done so by another user), Sitebricks is smart enough not to use the chained value.</p> \n<h3>Other Features</h3> \n<p>There is no requirement that the chained page needs to be created by Guice. It may or may not be. You can even return a subclass of the target page if that is useful to you (for example, an anonymous inner class).</p> \n<h3>Limitations</h3> \n<p>This is a simple enough API, but there are some caveats to keep in mind:</p> \n<ul> \n <li>You can only chain to pages that are mapped to a static URI, this is because Sitebricks does not know how to direct users to pages with a dynamic URI.</li> \n <li>If you want to return redirects to more than one page based on a condition, then you can return <code>Object</code> (or the nearest supertype of all those pages). However, the static analyzer may warn that you're not redirecting to a valid page.</li> \n <li><p>Page chaining requires that Sitebricks be configured with a working <code>FlashCache</code> by modifying your <code>AppConfig</code>:</p> <pre><code>@Override\npublic Injector getInjector() {\n    return Guice.createInjector(new SitebricksModule() {\n        @Override\n        protected void configureSitebricks() {\n            // ...\n            bind(FlashCache.class).to(HttpSessionFlashCache.class)\n                .in(Singleton.class);\n            // ...\n        }\n    });\n}\n</code></pre> <p>Here we are configuring Sitebricks to store pages between requests on the Http Session. This may be problematic for session clustering, and may increase memory usage when not serving requests.</p></li> \n</ul>","postedOn":"14 Sep 2011"}