{"id":"restful-webservices","title":"RESTful Web Services","html":"<p></p>  \n<p>This guides shows you how to build web services over HTTP.</p> \n<p>If you followed the getting started guide, then you know how to map pages to URLs and if you did the five minute tutorial, you know how to create Java methods that handle incoming HTTP requests like GET and POST. For standard HTML use cases this is plenty. Sitebricks also allows you to serve arbitrary types of content via the same mechanism. These may be images, json objects, XML or just about anything else you might want to expose via an API.</p> \n<p>If this is served or constructed dynamically, this kind of resource is called a web service.</p> \n<h3>No templates</h3> \n<p>The syntax for configuring web services is very similar to web pages, the exception being that you do not have an accompanying HTML template:</p> \n<pre><code>@At(&quot;/cart&quot;) @Service\npublic class ShoppingService {\n\n  @Get\n  Reply&lt;String&gt; hello() {\n    return Reply.with(&quot;hello there!&quot;);\n  }\n}\n</code></pre> \n<p>Note the use of the <code>@Service</code> annotation. This tells Sitebricks not to look for a corresponding template. The other difference is that we are now required to implement an event handler for HTTP GET requests:</p> \n<pre><code>@Get\nReply&lt;String&gt; hello() {\n  return Reply.with(&quot;hello there!&quot;);\n}\n</code></pre> \n<p>This is also fairly straightforward: you return a <code>Reply&lt;String&gt;</code> object with the string <code>&quot;hello there!&quot;</code>. By default Sitebricks is set up to serve this as a <code>text/plain</code> content type.</p> \n<h3>Replies</h3> \n<p>The <code>Reply&lt;E&gt;</code> object is typed with the class of the <em>entity</em> you want to respond with. In HTTP terms, an entity is an instance of a resource that you want to serve. For example, a shopping cart or a product item. The reply then serves as a wrapper API that generates the relevant HTTP response with the provided entity.</p> \n<p>If I wanted to send an entity as json rather than a plain text string, I can do so by configuring the reply appropriately:</p> \n<pre><code>@Get\nReply&lt;Product&gt; view() {\n  return Reply.with(new Product(&quot;Anti-ageing cure&quot;))\n              .as(Json.class);\n}\n</code></pre> \n<p>In this case, the <code>as()</code> rule is given a class that implements the <code>Transport</code> interface. You can create your own transports that generate content in whatever format you like (be it JPEG or ZIP or SOAP) or you can use one of the provided transports for convenience:</p> \n<ul> \n <li><code>Xml.class</code> - XStream based XML transport</li> \n <li><code>Json.class</code> - Jackson based Json transport</li> \n <li><code>Text.class</code> - Calls toString() on the entity and writes a UTF-8 String</li> \n</ul> \n<h3>Response Headers</h3> \n<p>Replies also allow you to set commonly used headers (such as content type) with a simple API step:</p> \n<pre><code>@Get\nReply&lt;Product&gt; view() {\n  return Reply.with(product)\n              .as(Json.class)\n              .type(&quot;application/json+product_viewer&quot;);\n}\n</code></pre> \n<p>This overrides the default content type set by the <code>Json.class</code> transport (text/json).</p> \n<p>Of course, you can also specify exactly what headers you want directly, with a map:</p> \n<pre><code>@Get\nReply&lt;Product&gt; view() {\n  Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;();\n  headers.put(&quot;Content-Type&quot;, &quot;application/json&quot;);\n  headers.put(&quot;X-Shopcart-Product-ID&quot;, &quot;123456&quot;);\n\n  return Reply.with(product)\n              .as(Json.class)\n              .headers(headers);\n}\n</code></pre> \n<h3>Statuses</h3> \n<p>Replies allow you to set the status of a response too. If you don't set one, the status code for <code>OK</code> (200) is set by default. Otherwise you can use one of the convenience methods to both set a status and perform an action.</p> \n<p>This sends a permanent redirect (301):</p> \n<pre><code>@Get\nReply&lt;?&gt; moved() {\n  return Reply.saying()\n              .seeOther(&quot;http://moved.permanently.com/other&quot;);\n}\n</code></pre> \n<p>This shows resource not found error (404):</p> \n<pre><code>@Get\nReply&lt;?&gt; err() {\n  return Reply.saying()\n              .notFound();\n}\n</code></pre> \n<p>... and so on. You can also explicitly set a status code of your own choice:</p> \n<pre><code>@Get\nReply&lt;?&gt; something() {\n  return Reply.with(&quot;some message&quot;)\n              .status(900);\n}\n</code></pre> \n<h3>Yes templates!</h3> \n<p>If you wish, you can render templates from these web services too. Here is the syntax:</p> \n<pre><code>@At(&quot;/person&quot;) @Service\npublic class PersonService {\n\n  @Get\n  Reply&lt;Person&gt; hello() {\n    return Reply.with(new Person(..))\n                .template(Person.class);\n  }\n}\n</code></pre> \n<p>Here, the class <code>Person</code> is used as the template indicator. Sitebricks expects that your data model object to be backed by a template:</p> \n<pre><code>@Show(&quot;PersonTemplate.html&quot;)\nclass Person {\n  ...\n}\n</code></pre> \n<p>This way, we cleanly separate model/view and control logic in our web services, in a concise and type-safe manner.</p>","postedOn":"14 d√©c. 2011"}