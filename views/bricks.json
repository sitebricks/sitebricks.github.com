{"id":"bricks","title":"Component Reuse","html":"<p></p>  \n<p>One of the mainstays of good programming principles is the ability to reuse code. In traditional MVC frameworks, this has taken the form of defining a special &quot;custom tag&quot; or component that services general functionality and can be used to render a fragment of a page over and over again.</p> \n<p>A typical example is an suggest box (an auto-completing textfield) like the one found on google.com. This custom bit of functionality is specific to the application is consideration and generally consists of the HTML and javascript required to make it work, as well as the backend logic to tie the whole thing together.</p> \n<p>In Sitebricks, this is no different from creating any other page</p> \n<h3>Bricks</h3> \n<p>A Sitebricks &quot;brick&quot; is characterized by a Java-like annotation placed on an HTML tag. For example, the @ShowIf brick determines if the annotated tag is rendered or not:</p> \n<pre><code>@ShowIf(isAutobot)\n&lt;span&gt; Transform and roll out!&lt;/span&gt;\n</code></pre> \n<p>This is not rendered if the page property isAutobot is false. Some bricks come out of the box, but it is very easy to create your own. Let's say you have a page that lists cartoon characters and some of their details:</p> \n<pre><code>List of Transformers:\n&lt;ul&gt;\n    &lt;li&gt;Hot Rod (Autobot)&lt;/li&gt;\n    &lt;li&gt;Soundwave (Decepticon)&lt;/li&gt;\n    &lt;li&gt;Quintesson (Other)&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre> \n<p>This simple static page can be made dynamic by fetching data from a datastore as follows:</p> \n<pre><code>List of Transformers:\n&lt;ul&gt;\n    @Repeat(items=transformers, var=&quot;bot&quot;)\n    &lt;li&gt;${bot.name} (${bot.affiliation})&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre> \n<p>And the corresponding page class:</p> \n<pre><code>@At(&quot;/cartoon/transformers&quot;)\npublic class TransformersPage {\n\n    private List&lt;Transformer&gt; transformers;\n\n    public List&lt;Transformer&gt; getTransformers() {\n        return this.transformers;\n    }\n\n    ...\n}\n</code></pre> \n<p>Easy enough, with the repeat brick. However, this means I have to duplicate such functionality for every single use of a list that displays cartoon characters and their affiliation. This can be generalized for reuse to save you much error prone copy/pasting and to enable making changes easier from one location.</p> \n<h3>Embedding Pages</h3> \n<p>First create an HTML template that has only the content you need to embed:</p> \n<pre><code>&lt;html&gt;\n    &lt;body&gt;\n\n        ${title}:\n        &lt;ul&gt;\n            @Repeat(items=characters, var=&quot;character&quot;)\n            &lt;li&gt;${character.name} (${character.affiliation})&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> \n<p>The corresponding page class looks like this:</p> \n<pre><code>@EmbedAs(&quot;CharacterList&quot;)\npublic class CharacterList {\n\n    private String title;\n    private List&lt;CartoonCharacter&gt; characters;\n\n    // getter + setters.\n}\n</code></pre> \n<p>Notice that the @At is missing and replaced by an annotation telling Sitebricks the name of this brick. Now every setter that you expose becomes an argument to the embedding brick annotation. So in the original transformers detail page:</p> \n<pre><code>&lt;body&gt;\n\n    The Transformers cartoon ran from 1978 to 1985 blah blah...\n\n    @CharacterList(characters=transformers, title=&quot;List of Transformers&quot;)\n    &lt;ul/&gt;\n\n&lt;/body&gt;\n</code></pre> \n<p>Now, sitebricks knows to bind the data list of transformers from the embedding page to the characters property in the brick, CharacterList (provided that Transformer is a subtype of CartoonCharacter). At runtime, it replaces the empty </p>\n<ul></ul> tag with the dynamic content generated by the CharacterList brick. \n<p>Similarly, you can just as easily reuse this brick in your other pages that display lists of cartoon characters:</p> \n<pre><code>&lt;body&gt;\n\n    Chaotic first began as a Danish card game, which was then made into a 56-episode season on the ...\n\n    @CharacterList(characters=overworlders, title=&quot;Denizens of Maxxor's Overworld&quot;)\n    &lt;ul/&gt;\n\n    @CharacterList(characters=underworlders, title=&quot;Minions of Kayor&quot;)\n    &lt;ul/&gt;\n\n&lt;/body&gt;\n</code></pre> \n<p>This is all statically verified at template compile time and you are not allowed to pass in any collection whose objects do not expose both properties name and affiliation required to render the composite page.</p> \n<h3>Additional Resources</h3> \n<p>In the embedded page, you may want to declare some specific CSS or JavaScript files. Use the @Require annotation to be sure it will be included.</p> \n<pre><code>&lt;html&gt; \n\n    &lt;head&gt;\n        @Require\n        &lt;script type=&quot;text/javascript&quot; src=&quot;myscript.js&quot;&gt;&lt;/script&gt;\n    &lt;/head&gt;\n\n    &lt;body&gt; \n        ...\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> \n<p>The script.js ressource will be included.</p> \n<h3>Bricks directory</h3> \n<p>These bricks are included in Sitebricks distribution package.</p> \n<ul> \n <li>@ShowIf : Hides or shows annotated tag content \n  <ul>\n   <li>Not self rendering</li> \n   <li>Usage @ShowIf(1+1 == 2)</li>\n  </ul></li> \n <li>@Repeat : Repeats annotated tag content over provided collection \n  <ul>\n   <li>Not self rendering</li> \n   <li>Usage @Repeat(items=movies, var=&quot;movie&quot;)</li>\n  </ul></li> \n <li>@TextField : A simple textbox with a property binding \n  <ul>\n   <li>Self rendering</li> \n   <li>Usage @TextField(myName)</li>\n  </ul></li> \n <li>@Require : Indicates the annotated tag must be rendered in \n  <html>\n   <ul>\n    <li>Not self rendering</li> \n    <li>Usage @Require</li>\n   </ul> \n   <li>@Include : Includes any 'called-with' bricks in the embedded brick \n    <ul>\n     <li>Not self rendering</li> \n     <li>Usage @Include</li>\n    </ul></li>  \n  </html></li>\n</ul>","postedOn":"15 d√©c. 2011"}